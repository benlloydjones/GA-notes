---
title: Resource Factories
type: lesson
duration: "1:25"
creator:
    name: Alex Chin
    city: LDN
competencies: Front-end frameworks
---

# Resource Factories

### Objectives
*After this lesson, students will be able to:*

- Refactor `$resource` as a factory
- Describe the difference between a factory and a service

### Preparation
*Before this lesson, students should already be able to:*

- Create http requests with `$http`
- Describe RESTful resources
- Build a Node RESTFUL API

## Angular Services - Intro (15 mins)

Each web application you build with Angular is composed of objects that collaborate to get stuff done. These objects need to be instantiated and wired together using [dependency injection](https://docs.angularjs.org/guide/di) for the app to work.

When you inject a dependency into a module, e.g.

```javascript
angular
  .module('lightsaberApp', [
    'ui.router',
    'ngResource'
  ]);
```

The injector service needs to know how it should insert these objects. It does this by using **recipes**.

#### Recipes

The main recipe that the injector needs to inject something into a module is called the **provider** recipe. However, on top of that, there are five other types of recipes which the injector uses to "cook" the dependency slightly differently. These recipes are:

1. **Factory** - the value returned by invoking the function reference
2. **Service** - the actual function reference
3. **Provider** - the value returned by invoking the $get method of the function reference
4. **Constant** - similar to a constant in other languages
5. **Value** - a literal value that can change

Each of these create a new object when they are used.

#### Services are Singletons

Angular [services](https://docs.angularjs.org/guide/services) (anything that can be injected as a dependency) are:

- **Lazily instantiated** – Angular only instantiates a service when it is needed
- **Singletons** – Each component dependent on a service gets a reference to the single instance generated by the service factory.  
> Note: Point out that a singleton is an object that there should only be one of.

Once instantiated, unlike a controller, it is persisted throughout the lifetime of our app.

If your app needs data from an API or database, we probably don't want to keep loading that same data every time we change routes. Fetching that data once and holding it in a service makes a lot of sense.

Also, because services are persistent singletons, they provide a mechanism to share data between controllers.

#### Factory vs service?

Factory and Service are the most commonly used recipes.  However, if factories and services are so similar, what's the difference? They look quite similar:

```js
angular
	.service('myService', myServiceFunction);

angular
	.factory('myFactory', myFactoryFunction);
```

**Service:**

...will be **new**-ed, always creating a new object.

```js
new myServiceFunction();
```

You should only make a service if you only ever need to and want to make one instance of it.

**Factory:**

...will be invoked, which _can_ return an object.

```js
myFactoryFunction();
```

It's possible to do the same things with both services and factories.

However, in some cases the factory gives you a little bit more flexibility because while the **service must always be an object**, the factory can be an object, a function reference, or any value at all.

## A factory model - Codealong (45 mins)

> Send out the _starter-code_

Setup with:

```sh
$ bower i && yarn install && gulp
```

Building from the lesson where we used the `$resource` service, we now want to refactor our code to use a custom service - specifically a factory service.

We could tell that including `$resource` into each of our separate controllers wasn't very DRY. We're going to fix this now!

Inside `src/js/`, let's first start by making a new directory for our new `$resource` factories.

Let's could call this directory `factories` - however you might see it referred to as `models` because this file is going to operate like a client-side model.

```bash
$ mkdir src/js/factories
```

Next, let's make a file for our Character factory:

```bash
$ mkdir src/js/factories/character.factory.js
```

We're going to use the same naming convention as a model on our backend - so singular.

#### Factory Boilerplate

Inside this file, let's add some boilerplate code for our factory service:

```js
angular
  .module('lightsaberApp')
  .factory('Character', Character);

Character.$inject = [];
function Character() {
}
```

This looks almost exactly the same as the boilerplate code for a controller!

#### Injecting our factory into `MainCtrl`

In order to use this factory in our `CharactersIndexCtrl`, we can now inject it!

```js
CharactersIndexCtrl.$inject = ['API', '$http', '$resource', 'Character'];
function CharactersIndexCtrl(API, $http, $resource, Character){
  //
}
```

Let's test that this has been injected correctly by just returning something from inside the factory. The factory must return an object:

```js
function Character() {
  return {
    test: 'Testing'
  };
}
```

Now **comment out** all of the code in our `CharactersIndexCtrl` and let's assign this new `Character` factory to `vm` so that we can test it in our view:

```javascript
angular
  .module('lightsaberApp')
  .controller('CharactersIndexCtrl', CharactersIndexCtrl);

CharactersIndexCtrl.$inject = ['API', '$http', '$resource', 'Character'];
function CharactersIndexCtrl(API, $http, $resource, Character){
  const vm  = this;

  vm.test = Character;

  // const Character = $resource(`${API}/characters/:id`,
  //   { id: '@id' }
  //   // {
  //   //   'get': { method: 'GET' },
  //   //   'save': { method: 'POST' },
  //   //   'remove': { method: 'DELETE' },
  //   //   'delete': { method: 'DELETE' },
  //   //   'query': { method: 'GET', isArray: true }
  //   // }
  // );
  //
  // vm.delete = charactersDelete;
  // vm.characters = Character.query();
  //
  // function charactersDelete(character){
  //   Character
  //     .delete({ id: character.id })
  //     .$promise
  //     .then(() => {
  //       charactersIndex();
  //     });
  // }
}
```

And finally bind it on our page in `src/js/views/characters/index.html` so that we can see if something was returned:

```html
{{ characters.test.test }}
```

You should see your string output!

#### Removing `$resource` from the controller

We can remove the test code from `index.html` and cut the code below from `CharactersIndexCtrl`:

```javascript
const Character = $resource(`${API}/characters/:id`,
  { id: '@id' },
  {
    // 'get': { method: 'GET' },
    // 'save': { method: 'POST' },
    // 'remove': { method: 'DELETE' },
    // 'delete': { method: 'DELETE' },
    // 'query': { method: 'GET', isArray: true },
    'update': { method: 'PUT' }
  }
);
```

Into the factory, like so:

```javascript
angular
  .module("lightsaberApp")
  .factory("Character", Character);

Character.$inject = [];
function Character(){
  return $resource(`${API}/characters/:id`,
    { id: '@id' },
    {
      // 'get': { method: 'GET' },
      // 'save': { method: 'POST' },
      // 'remove': { method: 'DELETE' },
      // 'delete': { method: 'DELETE' },
      // 'query': { method: 'GET', isArray: true },
      'update': { method: 'PUT' }
    }
  );
}
```

Remember to add the `$resource` to the factories dependencies.

```js
Character.$inject = ["API", "$resource"];
function Character(API, $resource){
  //
}
```

We can now remove the unnecessary dependencies from `CharacterIndexCtrl`:

In the controller:

```js
CharactersIndexCtrl.$inject = ['API', 'Character'];
function CharactersIndexCtrl(API, Character) {
  //
}
```

Great! Look how much DRYer our code is!

## Independent Practise

Now, go through the rest of the controllers and remove `$resource` and include `Character`.

> **NOTE:** Remember to move the `.update()` method!

## Bonus - Adding virtual properties

_Only cover if you have time._

Now that our new resource class is a function, we can attach extra functionality to its `prototype`! This is a little like adding methods in our mongoose schema!

For example, if we wanted to be able to easily access only the first name of our character, we could write our `Character` resource like this:

```javascript
function Character(API, $resource){
  const Character = $resource(`${API}/characters/:id`,
    { id: '@id' },
    {
      // 'get': { method: 'GET' },
      // 'save': { method: 'POST' },
      // 'remove': { method: 'DELETE' },
      // 'delete': { method: 'DELETE' },
      // 'query': { method: 'GET', isArray: true },
      'update': { method: 'PUT' }
    }
  );

  Character.prototype.firstName = function(){
    if (this.name) {
      if (this.name.indexOf(' ') === -1) return this.name;
      return this.name.slice(0, this.name.indexOf(' '));
    }
  };

  return Character;
}
```

This would give us a function to invoke in the HTML like this:

```html
{{ character.firstName() }}'s lightsaber
```

We could also use this with angular's extend:

```js
angular.extend(Character.prototype, {
  firstName: function() {
    if (this.name) {
      if (this.name.indexOf(' ') === -1) return this.name;
      return this.name.slice(0, this.name.indexOf(' '));
    }
  }
});
```

> **Note:** This will only work if you implement this on an instance of a Character resource.

Better yet, if you wanted to make `firstName` behave like a property instead of having to execute a function, try this on for size:

```javascript
function Character(API, $resource){
  const Character = $resource(`${API}/characters/:id`,
    { id: '@id' },
    {
      // 'get': { method: 'GET' },
      // 'save': { method: 'POST' },
      // 'remove': { method: 'DELETE' },
      // 'delete': { method: 'DELETE' },
      // 'query': { method: 'GET', isArray: true },
      'update': { method: 'PUT' }
    }
  );

  Object.defineProperty(Character.prototype, 'firstName', {
    get: function(){
      if (this.name) {
        if (this.name.indexOf(' ') === -1) return this.name;
        return this.name.slice(0, this.name.indexOf(' '));
      }
    }
  });

  return Character;
}
```

Now you can bind `firstName` to your view without having to invoke it as a function?!

```html
{{ character.firstName }}'s lightsaber
```

You now have the ability to create client-side resource models that mimic pretty much the model on the server!

#### The problem with `.query()`

In a real-world app, it's fairly rare that we'd want to retrieve every record in a database table. Imagine if there was 1,000,000 Jedis?! We might need to add some custom code in our resource...

## Conclusion (5 mins)

- How do you include NgResource in your App?
- What two syntaxes can you use to save an item with `$resource`
- Why does `query()` have no callback?